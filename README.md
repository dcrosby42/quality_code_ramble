
## "Quality Code" Ramble @ the CS club
### ...what goes into that?

* Make something that helps
* Make sure it keeps working
* Start again; keep learning

#### quality code is NOT

     best algorithm
     perfect efficiency
     awesome style 
     written by gurus


…rather, it provides *value*, (presumably) by *working correctly*

* Helps someone accomplish their goals.
* Way harder than it sounds. 
* There are gaps between the code you’re comfortable writing and what your customer can use.
  * If you care, you must close the gap.
  * Automation, new languages, tools, provisioning, deployment, certificates, accounts, installers.
          …come back tomorrow being an expert, please.


#### LOVE

* Passion for making software is supported by love of programming
* need to love it, because something’s got to keep you going amidst the onslaught of complexity and challenges
  * It’s not about finding your comfort zone and staying happy warm and cozy there
  * It’s about pushing forward, learning more, getting better
    * why?  customers don’t care if each line is lovingly crafted work of art.
  * I equate “love of programming” with “good (and fast) at learning how”
  *Getting the job done will require more of you than you signed up for

John says…  

	"it's important to find tools to help you know things are okay and that you can sleep tonight happily”
 

#### TESTING

* Get good at testing
  * Unit (easy, fun, quick) 
  * System (hard, frustrating, time-consuming) 

*(Also: Learn something about Context-Drive School of Testing and Exploratory Testers... these are our kind of testing folk.)*

TDD is past being a fad for the Cool Kids… it’s how software Craftspeople are making their livings and enjoying their work.
   
   * …and if testing is nothing but added work, why do so many great developers choose to do it on their own?  Even when pressured not to by their bosses? 

*Foreshadowing*: TDD lets you know your code works, whether it’s written elegantly or like a noob.
* Once it’s working you’ve got a choice: go back and improve the code (refactoring), or move on to something else.
* You'll be back later.  
   

#### GO WIDE, DIG DEEP

It's not about what you can do already; it's about what you'll need to do tomorrow to close the gap.

My current project uses these languages and tools to an extent that I need to read and write in them regularly:

	C. Ruby.  SQL.  HTML. HAML.  CSS. SASS.  Javascript. Coffee Script.  JSON. Handlebars. Hamlbars.
	Rbenv. Rails. Rake. Bundler.  Rspec. Cucumber.  Capybara/webkit. 
	HTTP.  Ajax.  jQuery.  Ember.js.  MQTT.
	Bash.  Linux.  Nginx.  Passenger.  Vagrant.  Chef.  

You never know what domain / tech platform you'll be doing battle in next:

	Web. Mobile. Desktop.  System.  Embedded.  Enterprise RDBMS.  NoSQL.

**Breadth:**

Start by learning enough to get going, get some things done.  (Lock it down with tests!)

*Eg, take an Ember tutorial, learn enough to get your app up and running, make forward progress.*

**Depth:**

As you begin moving forward, read more of the available Ember guides, and read the API documentation.  Try some experiments on the side.

When you upgrade and your tests start failing for no explicable reason, it might be time to dive into the source code for Ember itself, and see if you can trace the source of your problem, maybe even fix it and submit pull request.

Even if they taught Ember in college, you wouldn’t get the depth you may need some day.

Curiosity and joy help drive depth; you’ll spend extra time on your own developing understanding and skills.
     
